# 1st Master Prompt
```
You are a senior full-stack architect, ML engineer, and UX engineer.  
Your task is to redesign and implement a complete AI-powered "University Student Spending Coach" web app.

====================================================
[UI / CODE SOURCE PROVIDED ‚Äì IMPORTANT]

The project currently includes Vite+React code with the following structure:

- Dashboard.tsx
- ExpenseInput.tsx
- AIInsights.tsx
- CategoryAnalysis.tsx
- SpendingChart.tsx
- RecentTransactions.tsx
- BudgetSetting.tsx
- Settings.tsx
- ui/* (tooltip, popover, hover-card, skeleton, toggle, etc.)

These represent the Figma-generated UI components.  
You must reinterpret these as the **design blueprint** for the new system.

The redesigned UI must preserve the core layout but refactor it using:

- Next.js (App Router)
- React Server/Client Components
- TailwindCSS
- shadcn/ui design style (optional)

====================================================
[TECH STACK ‚Äî MUST FOLLOW]

Frontend:
  - Next.js 14 (App Router)
  - TypeScript + TailwindCSS
  - Deploy on Vercel

Backend:
  - Node.js (Next.js server actions or API routes)
  - Supabase (PostgreSQL + Auth)
  - AI/ML Microservice:
      - Python (pandas, scikit-learn)
      - FastAPI
      - Deployed on AWS/GCP (Cloud Run recommended)

====================================================
[PRODUCT GOAL ‚Äî FROM PRD]

Build an AI-powered "Spending Habit Coach" for university students.

Key modules:
1) Easy expense input (minimal steps)
2) Spending dashboard (chart, category breakdown)
3) AI insights (month-over-month, abnormal spikes, overspending detection)
4) Budget setting per category
5) Recent transactions
6) Category analysis
7) Settings

====================================================
[WHAT YOU MUST DELIVER]

Follow these steps exactly.

----------------------------------------------------
PHASE 1 ‚Äî UI / UX REINTERPRETATION

1) Reconstruct the entire UI hierarchy using Next.js route structure.
   Use the provided component list as a blueprint:
   - Dashboard
   - ExpenseInput
   - AIInsights
   - CategoryAnalysis
   - SpendingChart
   - RecentTransactions
   - BudgetSetting
   - Settings
   - Common UI (popover, tooltip, alert, skeleton)

2) Create a full component architecture:
   - Page components (/dashboard, /transactions, /settings, /budget)
   - Subcomponents (Charts, Cards, InsightList, TransactionTable)
   - Modal for Add Expense (FAB-based)
   - Navigation (top or sidebar)
   - Responsive layout system

3) Produce Tailwind-friendly wireframes + React skeleton code.

----------------------------------------------------
PHASE 2 ‚Äî DATABASE & SUPABASE

4) Design Supabase schema:
   - users
   - transactions
   - categories
   - budgets
   - ai_insights (generated by ML)
   - challenge (future use)
   Include types & relationships.

5) Provide SQL or Supabase migration formats.

6) Show how frontend connects to Supabase for CRUD actions using the official JS client.

----------------------------------------------------
PHASE 3 ‚Äî PYTHON ML PIPELINE (FASTAPI)

7) You MUST use the CSV dataset structure similar to:
   - date
   - amount
   - description
   - category
   - payment method
   - merchant/store name

8) In pandas:
   - Load ‚Üí clean ‚Üí feature engineer ‚Üí aggregate to user-month features.

9) Build light ML models with scikit-learn:
   - KMeans (spending personas)
   - Trend detection (month-over-month % diff)
   - Overspending risk prediction (logistic regression or baseline rules)

10) Implement and persist models (joblib).

11) Build FastAPI endpoints:
   - POST /predict/insights
   - GET /health
   - (Optional) POST /train

12) Responses should map to:
   - Insight type
   - Severity
   - Suggested action
   - Potential saving amount

----------------------------------------------------
PHASE 4 ‚Äî NEXT.JS + FASTAPI INTEGRATION

13) Implement a client wrapper in Next.js to call the FastAPI service.

14) Integrate insights into the Dashboard using:
   - AIInsights component
   - CategoryAnalysis
   - SpendingChart

15) Render insights as cards (Tailwind + shadcn/ui)

----------------------------------------------------
PHASE 5 ‚Äî DEPLOYMENT

16) Provide a deployment strategy:
   - Vercel for Next.js
   - AWS/GCP (Cloud Run) for FastAPI
   - Environment variables for API URLs, Supabase keys, DB URLs

----------------------------------------------------
PHASE 6 ‚Äî DELIVERABLE FORMAT

17) Provide:
   - Full architecture diagram (text-based)
   - Folder structure for Next.js project
   - Code snippets (TSX, API handlers, Python scripts)
   - Explanation of each module
   - How to run both dev and prod environments
   - How to retrain the ML model with new spending data

====================================================
[STYLE]

- Think step by step
- Be explicit with reasoning
- Include code where needed
- Use correct TypeScript + Python types
- Prioritize clarity & scalability

Now begin with PHASE 1, step 1:
"Reinterpret the UI hierarchy using the provided components."

```

# 2nd Í∏∞Îä• Ï∂îÍ∞Ä ÌîÑÎ°¨ÌîÑÌä∏
## Îã§ÌÅ¨Î™®Îìú
```
You are a senior frontend engineer and design systems expert.

Context:
- Tech stack:
  - Next.js (App Router)
  - React
  - TypeScript
  - TailwindCSS
  - Some shadcn/ui-like primitives (tooltip, popover, card, skeleton, etc.)
- The app includes components such as:
  - Dashboard
  - ExpenseInput
  - AIInsights
  - CategoryAnalysis
  - SpendingChart
  - RecentTransactions
  - BudgetSetting
  - Settings

IMPORTANT:
- Dark mode is ALREADY PARTIALLY IMPLEMENTED.
- However, some colors are wrong or inconsistent:
  - Certain backgrounds are too bright or too dark in dark mode.
  - Some text is low-contrast or invisible on dark backgrounds.
  - Some components still use hard-coded colors (#fff, #000, etc.) instead of theme tokens.
- Your job is NOT just to add dark mode from scratch.
- Your job is to:
  1) AUDIT the existing color system and dark mode behavior,
  2) FIX broken or inconsistent colors,
  3) STABILIZE the light/dark theme so it looks polished.

====================================================
[Goals]

1) Use Tailwind `darkMode: "class"` (or confirm it is already configured correctly).
2) Build or refine a semantic color system with CSS variables, such as:
   - bg-background, bg-card, bg-muted
   - text-foreground, text-muted
   - border-border
   - accent, accent-foreground
3) Ensure both light and dark themes are:
   - Visually consistent across all pages
   - Readable (WCAG-compliant contrast, or at least reasonable)
   - Free of hard-coded, mode-breaking colors.

====================================================
[What you MUST pay special attention to]

You MUST carefully inspect and adjust:

1) Tailwind & global styles:
   - `tailwind.config.(js|ts)`
   - `globals.css` (or equivalent)
   - `index.css` or other global styles
   - Any CSS variables under :root and .dark selectors

2) Components with likely color bugs:
   - Dashboard layout (background + nested cards)
   - AIInsights (insight cards, severity badges, etc.)
   - SpendingChart (chart grid, axis labels, tooltip colors)
   - CategoryAnalysis (chips, legends, badges)
   - RecentTransactions (table rows, hover states)
   - BudgetSetting (progress bars, warnings)
   - Settings (form fields, toggles, section titles)

3) Problem patterns to find and fix:
   - Hard-coded colors like:
     - `#fff`, `#ffffff`, `#000`, `#000000`
     - direct Tailwind colors not mapped to semantic tokens (e.g., `bg-white`, `bg-black`, some `bg-slate-xxx`)
   - Inline styles that conflict with theme.
   - Components that look fine in light mode but break visually in dark mode.

====================================================
[Step-by-step tasks]

Follow these steps in order. Use ‚ÄúLet‚Äôs think step by step‚Äù internally.

STEP 1 ‚Äî Analyze Existing Theme
- Examine tailwind.config and global CSS.
- Identify:
  - How dark mode is currently triggered (class vs media).
  - What CSS variables (if any) are defined for colors.
  - Where light/dark variants are currently set.

STEP 2 ‚Äî Define or Refine Semantic Tokens
- Propose a minimal, semantic color token set, for example:
  - `--background`, `--foreground`
  - `--card`, `--card-foreground`
  - `--muted`, `--muted-foreground`
  - `--border`
  - `--accent`, `--accent-foreground`
  - `--destructive`, `--destructive-foreground`
- Define values for both `:root` (light) and `.dark` (dark).
- Ensure the palette is consistent with a modern, slightly neutral style (suitable for a finance dashboard).

STEP 3 ‚Äî Tailwind Integration
- Update tailwind.config to map Tailwind utilities to the CSS variables, e.g.:
  - `background: "hsl(var(--background))"`
  - `foreground: "hsl(var(--foreground))"`
- Show the updated config snippet.

STEP 4 ‚Äî Audit & Fix Components
- For each of the key components:
  - Dashboard
  - AIInsights
  - SpendingChart
  - CategoryAnalysis
  - RecentTransactions
  - BudgetSetting
  - Settings
- Do the following:
  1) Identify ANY hard-coded or suspicious color usages.
  2) Replace them with semantic classes (e.g., `bg-background`, `bg-card`, `text-muted-foreground`).
  3) Ensure hover/focus/active states have appropriate contrast in both light and dark mode.
  4) For charts and special visuals, propose a light/dark friendly color set.

- Provide concrete before/after examples when you fix a color:
  - Show the old code snippet.
  - Show the improved code snippet.
  - Explain why the new version works better in dark mode.

STEP 5 ‚Äî Theme Toggle Component
- Implement a reusable `<ThemeToggle />` component that:
  - Supports "light", "dark", and "system" modes.
  - Uses `prefers-color-scheme` for system mode.
  - Persists user choice in `localStorage` (e.g., `theme = "light" | "dark" | "system"`).
  - Safely updates the `class` on `<html>` to avoid hydration issues.

- Integrate the toggle into:
  - Main layout header, and/or
  - Settings page.

STEP 6 ‚Äî Visual Sanity Check & Guidelines
- Provide guidance for future components:
  - Which classes to use for surface backgrounds, cards, text, etc.
  - Example patterns:
    - Page background: `bg-background text-foreground`
    - Card: `bg-card text-card-foreground border-border`
    - Muted sections: `bg-muted text-muted-foreground`
    - Warnings: `bg-destructive/10 text-destructive border-destructive/30`
- Explain common pitfalls in dark mode and how to avoid them.

====================================================
[Output Format]

- Use clear headings for each step.
- Show updated Tailwind config.
- Show CSS variable definitions for light/dark.
- Show representative component refactors (Dashboard, AIInsights, etc.).
- Explain the reasoning behind color choices and fixes.

Be extra careful to NOT simply overwrite everything blindly.
Instead, audit ‚Üí reason ‚Üí fix, especially where current colors are broken or unreadable in dark mode.
```

## ÏàòÏ†ï, ÏÇ≠Ï†ú Í∏∞Îä• Ï∂îÍ∞Ä
```
You are a senior full-stack engineer.

Context:
- We are building an ‚ÄúAI Spending Coach‚Äù web app for university students.
- Tech stack:
  - Next.js (App Router)
  - React
  - TypeScript
  - TailwindCSS
  - Supabase (PostgreSQL + Auth)
- We already have:
  - A transaction input component (e.g., ExpenseInput)
  - A transaction list component (e.g., RecentTransactions)
  - A Dashboard page that shows recent transactions and charts.

Goal:
Add robust **EDIT** and **DELETE** functionality for transactions
with proper UX, data integrity, and Supabase integration.

====================================================
[Data Model Assumptions]

Assume a Supabase table `transactions` roughly like:

- id (uuid, primary key)
- user_id (uuid, FK to auth.users)
- amount (numeric)
- category_id or category (string or FK)
- memo / description (text)
- date (timestamptz or date)
- created_at (timestamptz)
- updated_at (timestamptz)
- is_deleted (boolean, default false)  // optional for soft delete

If you need to adjust this schema, propose the changes explicitly.

====================================================
[What I want you to do]

Use ‚ÄúLet‚Äôs think step by step‚Äù internally and proceed in the following phases.

----------------------------------------------------
PHASE 1 ‚Äì UX & Flow Design

1) Analyze and define the UX around editing and deleting transactions:
   - Where the edit/delete entry points should live:
     - e.g., action buttons (üñä Edit / üóë Delete) in each row of RecentTransactions.
   - Decide whether editing happens:
     - in a modal dialog, OR
     - inline expansion of the row.
   - Define the flow:
     - User clicks "Edit" ‚Üí existing values are loaded ‚Üí user edits ‚Üí validation ‚Üí save ‚Üí list updates.
     - User clicks "Delete" ‚Üí confirmation dialog ‚Üí soft delete (set is_deleted = true) or hard delete ‚Üí list updates.

2) Describe the UI states you will support:
   - Idle, loading, success, error.
   - Optimistic update vs. refetch on success.

----------------------------------------------------
PHASE 2 ‚Äì Supabase / Backend Layer

3) Ensure the Supabase schema supports:
   - updated_at column (auto-updated on change).
   - optional is_deleted column for soft delete.

4) Show SQL or Supabase migration statements to:
   - Add updated_at with default now(), if missing.
   - Add is_deleted boolean with default false, if we choose soft delete.
   - Add useful indexes if needed (user_id, date, is_deleted).

5) Explain the security model:
   - Only the owner (user_id) can edit or delete their own transactions.
   - RLS (Row Level Security) policies (outline the policy statements).

6) Implement (or describe) the API layer:
   - Either:
     - Use Supabase client directly in server components / server actions, OR
     - Create dedicated Next.js API routes, such as:
       - PATCH /api/transactions/[id]
       - DELETE /api/transactions/[id]
   - For each endpoint or server action:
     - Input validation (id, amount, date, etc.).
     - Auth check (ensure user matches user_id).
     - Update or soft-delete the row.
     - Return the updated transaction or a success flag.

Provide TypeScript examples of these functions/endpoints.

----------------------------------------------------
PHASE 3 ‚Äì Frontend Integration (React + Next.js + Tailwind)

7) Update the RecentTransactions component to include actions:
   - For each transaction row, add:
     - ‚ÄúEdit‚Äù button
     - ‚ÄúDelete‚Äù button (or icon)
   - Show how props and types are structured:
     - Transaction type (id, amount, category, date, memo, etc.).

8) Implement an Edit Transaction UI:
   - Prefer a modal dialog:
     - Pre-filled fields: amount, category, memo, date.
     - Basic validation (non-empty, amount > 0, valid date).
   - Show a React component, e.g. `<EditTransactionDialog />`:
     - Props: transaction, onClose, onSave.
   - On save:
     - Call the backend (server action or API route).
     - Show loading state on the button.
     - Handle success:
       - Update the local list (optimistic) OR refetch.
     - Handle error:
       - Show an error message (e.g., toast or alert).

9) Implement Delete Transaction UX:
   - A confirmation dialog or simple confirm modal:
     - ‚ÄúAre you sure you want to delete this transaction?‚Äù
   - On confirm:
     - Call delete API / server action.
     - Either:
       - Remove the item from the list optimistically, OR
       - Refetch the list.
   - Handle loading and error states.

10) Provide concrete example code:
   - Updated `RecentTransactions.tsx` or equivalent.
   - `EditTransactionDialog.tsx` component.
   - Optional `ConfirmDialog` component for delete.
   - Any related hooks:
     - `useTransactions()`, `useEditTransaction()`, `useDeleteTransaction()`.

Use TailwindCSS classes for basic styling and keep the UI consistent with a finance dashboard.

----------------------------------------------------
PHASE 4 ‚Äì State Management & Refresh

11) Describe how you will keep the UI in sync:
   - Recommended approach:
     - Use React Query / SWR, OR
     - Simple state + refetch logic per page.
   - When a transaction is edited or deleted:
     - Explain whether you:
       - Mutate local state directly, OR
       - Trigger a re-fetch from Supabase.

12) Show sample code snippets for:
   - Fetching transactions from Supabase (server or client).
   - Updating cache/state after mutation.

----------------------------------------------------
PHASE 5 ‚Äì Edge Cases & Validation

13) Consider edge cases:
   - User tries to edit a transaction that no longer exists.
   - Network error during update/delete.
   - User double-clicks delete or spam-clicks buttons.
   - Timezone issues for date handling.

14) Implement defensive checks in code:
   - Disable buttons while loading.
   - Graceful error messages.
   - Default/fallback values if some fields are missing.

====================================================
[Output Format]

- Use clear headings for each PHASE and STEP.
- Provide:
  - Supabase schema/migration snippets.
  - RLS policy examples (even if simplified).
  - Example Next.js API routes or server actions.
  - React + TSX component code for:
    - Updated transaction list
    - Edit dialog
    - Delete confirmation
- Explain the reasoning behind each design choice (soft-delete vs hard-delete, optimistic vs refetch, etc.).

Start with PHASE 1: describe the UX for editing and deleting transactions based on a typical RecentTransactions list.
```
## UI ÏàòÏ†ï Prompt 1
```
You are a senior frontend architect and product engineer.

Context:
- Tech stack:
  - Next.js (App Router)
  - React
  - TypeScript
  - TailwindCSS
  - Supabase (PostgreSQL + Auth)
  - (Optional) external AI/ML service for insights
- Existing key components (names may be approximate):
  - Dashboard.tsx
  - SpendingChart.tsx
  - CategoryAnalysis.tsx
  - AIInsights.tsx
  - RecentTransactions.tsx
  - BudgetSetting.tsx
  - Settings.tsx

The product is an ‚ÄúAI Spending Coach‚Äù for university students.  
The UI is already implemented but needs targeted improvements and bug fixes.

====================================================
[Primary UI Issues To Fix]

You must focus on the following 4 items:

1) Budget Inconsistency Bug
   - Problem:
     - In the new profile environment vs existing profile environment,
       the budget shown in the Dashboard "Budget Summary" and the budget shown in the dedicated "Budget" tab (or BudgetSetting page) are different / inconsistent.
   - Goal:
     - Ensure that:
       - The Dashboard‚Äôs budget section
       - The Budget tab/page (BudgetSetting)
       both read from the same source of truth and display consistent values.
     - This must work correctly for:
       - Existing users / profiles
       - Newly created users / profiles

2) Weekly Spending Trend ‚Üí Support Weekly / Monthly / Daily Views
   - Problem:
     - The ‚ÄúWeekly Spending Trend‚Äù widget in the Dashboard currently only shows weekly data.
   - Goal:
     - Modify this widget so that users can switch between:
       - Daily view
       - Weekly view
       - Monthly view
     - Provide a clean toggle UI (e.g., segmented control / tabs: [Daily | Weekly | Monthly]).
     - Ensure the chart labels, aggregation, and date ranges change correctly with the selected view.

3) AI Insights Tab ‚Äì Add Insight Categories
   - Problem:
     - The AI Insights section on the Dashboard does not yet reflect the categorized tabs that exist in the ‚ÄúInsights‚Äù view.
   - Goal:
     - In the Dashboard‚Äôs AI Insights area, add tabs (or pill-style segmented controls) with:
       - ‚ÄúInsights‚Äù (general insights)
       - ‚ÄúPotential Savings‚Äù (Ï†àÏïΩ Í∞ÄÎä•)
       - ‚ÄúWarnings‚Äù (Ï£ºÏùò Ìï≠Î™©)
     - The content should filter or group AI insight cards according to these categories.
     - The tab structure should be consistent with any existing ‚ÄúInsights‚Äù page/tab in the app.

4) Merge Weekly Spending Trend & Category Spending Sections
   - Problem:
     - The Dashboard currently has:
       - A ‚ÄúWeekly Spending Trend‚Äù section.
       - A separate ‚ÄúSpending by Category‚Äù section.
     - These are visually and functionally separate, potentially redundant.
   - Goal:
     - Design and implement a unified component or section that combines:
       - Time-series spending trend (by day/week/month).
       - Category-wise breakdown (e.g., stacked chart, toggle between ‚ÄúTrend‚Äù and ‚ÄúBy Category‚Äù).
     - The UX should make it easy for users to:
       - Understand how spending evolves over time.
       - See which categories contribute most to that spending.
     - You may use:
       - Tabs inside the same card:
         - [Trend] vs [By Category]
       - Or a layout where charts share controls (e.g., range selector that affects both).

====================================================
[What You MUST Do ‚Äì Step by Step]

Use ‚ÄúLet‚Äôs think step by step‚Äù internally.  
Proceed in the following phases:

----------------------------------------------------
PHASE 1 ‚Äì Analyze Existing UI Structure

1) Infer or propose the current UI/route structure:
   - Dashboard page (e.g., `/dashboard`)
   - Budget tab/page (e.g., `/dashboard/budget` or `/budget`)
   - Insights tab/page (if separate)
   - Components:
     - `<Dashboard />`
     - `<SpendingChart />`
     - `<CategoryAnalysis />`
     - `<AIInsights />`
     - `<BudgetSetting />`
   - Explain where each of the 4 issues likely manifests in the code.

2) Propose a revised high-level layout for the Dashboard:
   - Sections:
     - Header (profile, summary)
     - Budget summary
     - Unified ‚ÄúTrend & Category‚Äù section
     - AI Insights section (with the required tabs)
     - Recent transactions (if present)
   - Make sure the layout works for both desktop and mobile.

----------------------------------------------------
PHASE 2 ‚Äì Fix Budget Inconsistency (New vs Existing Profile + Dashboard vs Budget Tab)

3) Define a single source of truth for budgets:
   - e.g., Supabase table `budgets` with columns:
     - user_id
     - period (month/year)
     - total_budget
     - per_category_budget (JSON or relational)
   - Or align with the existing schema if one already exists.

4) Identify how the Dashboard currently reads budget data vs how the Budget tab reads it:
   - If needed, propose refactoring:
     - Move budget fetching logic into a shared hook or server function:
       - `useUserBudget()` or a server action `getUserBudget(userId, period)`.
   - Ensure consistent behavior for:
     - New profiles (no budget yet)
     - Existing profiles (predefined budgets).

5) Implement:
   - A unified budget fetching function (server or client).
   - Update both:
     - Dashboard budget summary
     - BudgetSetting component/page
     to use this shared function or hook.
   - Show TypeScript code examples for:
     - The shared utility/hook.
     - Updated Dashboard budget section.
     - Updated Budget tab UI.

6) Handle edge cases:
   - No budget set yet:
     - Show a CTA like ‚ÄúSet your first budget‚Äù linking to Budget tab.
   - Multiple periods (e.g., month selection).

----------------------------------------------------
PHASE 3 ‚Äì Enhance Spending Trend to Support Daily/Weekly/Monthly Views

7) Extend the SpendingChart component:
   - Add a `viewMode` state: `"daily" | "weekly | "monthly"`.
   - Add a UI control (tabs or segmented control) to switch the view.
   - Implement data aggregation logic:
     - Daily: raw per-day sums.
     - Weekly: sum by week number.
     - Monthly: sum by month.
   - Ensure the X-axis labels, tooltips, and legend reflect the mode.

8) Provide concrete React + TypeScript code:
   - Component props and state.
   - Example using a chart library (e.g., Recharts) to render different views.
   - Tailwind classes for a clean UI (e.g., small pill buttons).

----------------------------------------------------
PHASE 4 ‚Äì AI Insights Tabs (Insights / Potential Savings / Warnings)

9) Design the data model for AI insights:
   - At least:
     - id
     - user_id
     - type: `"insight" | "saving" | "warning"`
     - title
     - message
     - severity (optional)
     - created_at
   - Or align with existing schema if already defined.

10) Update the AIInsights component:
    - Add a tab or segmented control with:
      - ‚ÄúInsights‚Äù
      - ‚ÄúPotential Savings‚Äù
      - ‚ÄúWarnings‚Äù
    - Filter displayed insight cards by `type` based on the selected tab.
    - Handle case where a tab has no items (empty state message).

11) Provide concrete example code:
    - Tab UI implementation (e.g., using a simple button group or shadcn/ui Tabs).
    - Insight card layout.
    - Data fetching and filtering logic.

----------------------------------------------------
PHASE 5 ‚Äì Merge Weekly Trend & Category Spending Sections

12) Propose a unified section/component:
    - Name: e.g., `<SpendingOverviewSection />`.
    - Contains:
      - Controls:
        - View mode: [Daily | Weekly | Monthly]
        - Sub-tabs: [Trend] / [By Category]
      - Content:
        - Trend view: time-series chart of total spending.
        - By Category view: pie chart, bar chart, or stacked area by category.

13) Implement the unified component:
    - Show TypeScript React code that:
      - Shares date range + view mode state.
      - Reuses or composes:
        - `<SpendingChart />` (for trend)
        - `<CategoryAnalysis />` (for category breakdown)
      - Uses a consistent visual style (cards, shadows, spacing).

14) Remove or refactor old separate sections:
    - Replace individual ‚ÄúWeekly Spending Trend‚Äù and ‚ÄúSpending by Category‚Äù sections with the new unified section in Dashboard.

----------------------------------------------------
PHASE 6 ‚Äì Final Polish & Consistency

15) Review overall Dashboard UX:
    - Ensure the following are visually and functionally coherent:
      - Budget summary & Budget tab.
      - Spending overview (trend + category).
      - AI Insights with tabs.
    - Suggest any minor UI tweaks (spacing, headings, labels) to improve clarity.

16) Provide:
    - Final proposed `Dashboard.tsx` layout (high-level code).
    - Short explanation for each major section.
    - Notes on how to extend this later (e.g., adding custom date ranges).

====================================================
[Output Format]

- Use clear headings per PHASE.
- Provide code snippets in TypeScript + React + Tailwind.
- Explain your reasoning when choosing specific UI patterns (tabs vs toggles, merged sections, etc.).
- Make sure all changes are compatible with Next.js App Router.

Start with PHASE 1: analyze the current Dashboard layout and show how you will reorganize it to accommodate the 4 required changes.

```